<!doctype html><html lang=en-US><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>“Implementation Selection” in Rust — Andrew Lilley Brinker — Software Supply Chain Security</title><meta content="“Implementation Selection” in Rust — Andrew Lilley Brinker — Software Supply Chain Security" name=title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" name=description><meta content=website property=og:type><meta content=https://www.alilleybrinker.com property=og:url><meta content="“Implementation Selection” in Rust — Andrew Lilley Brinker — Software Supply Chain Security" property=og:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=og:description><meta content=https://www.alilleybrinker.com/social.png property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://www.alilleybrinker.com property=twitter:url><meta content="“Implementation Selection” in Rust — Andrew Lilley Brinker — Software Supply Chain Security" property=twitter:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=twitter:description><meta content=https://www.alilleybrinker.com/social.png property=twitter:image><link href=https://www.alilleybrinker.com/main.css rel=stylesheet><body><div class="my-4 md:m-16 px-4 md:px-0 md:mx-auto subpixel-antialiased w-fit text-sm md:text-base"><div class="mb-6 md:mb-8"><nav><ul class="flex gap-4"><li><a class="hover:underline font-semibold" href=https://www.alilleybrinker.com/><span class=h-card><span class=p-given-name>Andrew</span> <span class=p-family-name>Lilley Brinker</span></span></a><li class=text-gray-400>/<li><a class=hover:underline href=https://www.alilleybrinker.com/blog/>Blog</a></ul></nav></div><h1 class="block mb-6 text-xl md:text-2xl font-bold">“Implementation Selection” in Rust <span class="block md:inline text-sm md:text-base text-gray-500 font-normal md:ml-4">Posted on January 23, 2024</span> <span class="text-sm md:text-base text-gray-500 font-normal mr-2 md:mr-0 md:ml-4"> <a class="text-xs relative -top-[2px] py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.alilleybrinker.com/topics/rust/>Rust</a> </span></h1><div class="md:flex gap-16"><div class="prose prose-sm md:prose-base prose-p:text-black prose-li:text-black prose-a:text-black prose-a:font-normal prose-a:decoration-1 hover:prose-a:decoration-2 prose-a:underline-offset-2 hover:prose-a:underline-offset-auto prose-a:decoration-gray-400 hover:prose-a:decoration-gray-800 prose-code:after:content-[''] prose-code:before:content-[''] prose-blockquote:font-normal prose-blockquote:not-italic prose-blockquote:text-base prose-figure:bg-sky-50 prose-figure:p-4 prose-figure:rounded-md prose-blockquote:border-l-sky-200 prose-blockquote:text-sky-900 prose-figcaption:text-sky-900 prose-figcaption:opacity-70"><p>A common problem in programming is when you want the path of options for “what happens next” to split. In structured programming this would generally come in the form of a series of <code>if</code>/<code>else if</code>/<code>else</code> (or whatever the syntax is in your preferred language), or a <code>switch</code> if your language supports it. Maybe you have a ternary operator for a more compact <code>if</code>/<code>else</code>. <em>Maybe</em> you go whole-hog and have some array of function pointers to embed the selection into data. Whatever way you slice it, you have paths of control flow, and you want to choose between them in a structured fashion.</p><span id=continue-reading></span><p>Another way to enable this kind of selection is through the use of polymorphism. In an Object-Oriented framing, this might mean subtype polymorphism via the use of child classes of some shared parent class. This notion is in some way an extension of the “array of function pointers” approach, except instead of an explicit array of function pointers like you might find in C, you instead have, for each object, an implicit set of function pointers for the method implementations in each subclass, and the language dispatches to those based on the concrete type being handled.<p>Depending on the language, the nature of overriding, method lookup, etc. may differ, but the general notion is the same. Objects have some associated set of functions to which function calls in the caller are dispatched according to the concrete type. We’ve elevated implementation from the value level to the type level. This is convenient!<p>In Rust, my own preferred language, you have instead a nice little grid of four options for “implementation selection,” which vary based on whether dispatch is done at compile time or run time, and whether the set of types which may be used is “open” (meaning third-parties can use their own types) or “closed” (meaning only the types intended by the original creator may be used).<table><thead><tr><th style=text-align:left><th style=text-align:left>Resolved at compile time<th style=text-align:left>Resolved at runtime<tbody><tr><td style=text-align:left>Open set of types<td style=text-align:left>Generics params with trait<td style=text-align:left>Trait objects<tr><td style=text-align:left>Closed set of types<td style=text-align:left>Generic params with sealed traits<td style=text-align:left>Enum</table><p>Let’s cover each of these in turn:<h2 id=1-generic-parameters-with-traits>1. Generic Parameters with Traits</h2><p>This is Rust’s standard mechanism for parametric polymorphism. You have a generic function, with the generic type bounded by some trait(s). In this case, the calls to the generic function are resolved at compile time, meaning the generic function is monomorphized to produce a non-generic copy of it specialized for each concrete type the function is called with, and the newly-generated concrete functions are swapped in for the generic function at the callsite.<p>This gives you fast run time behavior (no dispatching / pointer chasing to do), but you spend a bit more time on code generation during compilation, and the object file size generally gets bigger. It also limits separate compilation, because the generic code needs to know the concrete type(s) it’s getting called with.<p>You also, crucially, don’t control the types which can be passed to the generic function. In this category, the trait(s) involved are public, so third-parties can implement them for their own types. This is <em>usually</em> desirable, as it lets you write flexible APIs that expand to fit future needs or the needs of others which you can’t predict.<h2 id=2-generic-parameters-with-sealed-traits>2. Generic Parameters with Sealed Traits</h2><p>In this quadrant, the trade-offs are the same as for generics with unsealed traits, with the exception that you’ve now limited the set of types to be “closed.” So now, the <em>only</em> types which can be passed to the generic function are <em>your own</em> types which have implemented the relevant trait.<p>This lets you have the benefits of generics in your own code without exposing a generic API you don’t actually intend to be generic.<p>On the other hand, consumers of your code may be put off by seeing a generic mechanism which they can’t actually use (we often want whatever we can’t have), and it also means more complex function signatures versus manually (or with the help of macros) writing out each version of the function for the concrete types by hand.<h2 id=3-trait-objects>3. Trait Objects</h2><p>Trait objects work like generic parameters with traits, in that a function can be polymorphic over the concrete type they’re handling, but it moves function dispatch from compile time to run time. There are some limitations here, namely that not all traits in Rust can be made into trait objects (this limitation is based on “object safety,” and the specific rules basically codify that only traits whose dispatch <em>can</em> be handled at run time can be made into trait objects).<p>Trait objects are powerful, and I’ve actually written about them before. On Possible Rust I write <a href=https://www.possiblerust.com/pattern/3-things-to-try-when-you-can-t-make-a-trait-object>“3 Things to Try When You Can’t Make a Trait Object,”</a>. Looking back at that article now, I realize the first two suggestions are literally suggestions to move on step in either direction on the grid I shared at the start of this article. Option 1 is “Try an enum” (meaning close the set of types which is currently open), Option 2 is “try type erasure” (meaning use a trick from David Tolnay to span a non-object safe trait into an object-safe equivalent trait so you <em>can</em> make a trait object). So option 1 is about moving down one in the quadrant, and option 2 is about moving to the left.<p>At any rate, trait objects are great, and powerful, though you pay a cost with run time dispatch. You should benchmark and see if that cost is relevant for you.<h2 id=4-enumerations>4. Enumerations</h2><p>Finally, <code>enum</code>s, one of Rust’s most powerful features. Enums let you list a set of data-carrying variants, one of which will be present at runtime. Then, when using the enum type, you <code>match</code> (or use a <code>match</code>-equivalent) to select the right behavior.<p>This is, conceptually, similar to the good-old <code>if</code>/<code>else if</code>/<code>else</code> chaining, or to <code>switch</code>, but with the added benefit of exhaustiveness checking. The compiler makes sure you cover <em>all</em> possible variants of the enum when selecting the right behavior, so you don’t miss any possibilities.<h2 id=conclusion>Conclusion</h2><p>Nothing said in this post is revelatory, but hopefully it provides a helpful description of the option space here when you want to be able to have some “implementation selection” in your program. Just remember the table:<table><thead><tr><th style=text-align:left><th style=text-align:left>Resolved at compile time<th style=text-align:left>Resolved at runtime<tbody><tr><td style=text-align:left>Open set of types<td style=text-align:left>Generics params with trait<td style=text-align:left>Trait objects<tr><td style=text-align:left>Closed set of types<td style=text-align:left>Generic params with sealed traits<td style=text-align:left>Enum</table></div><div class="mt-8 md:mt-0 md:max-w-60"><figure class=mb-8><img class="rounded-full max-w-48" src=https://www.alilleybrinker.com/image/andrew.png></figure><p class="block text-xs mb-4 uppercase font-semibold">Elsewhere<ul class="mb-8 flex flex-wrap gap-x-1 gap-y-2"><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://github.com/alilleybrinker> GitHub </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://x.com/alilleybrinker> Twitter <span class=text-gray-500/75>/</span> X </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://bsky.app/profile/alilleybrinker.com> Bluesky </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://hachyderm.io/@alilleybrinker> Mastodon </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.linkedin.com/in/alilleybrinker> LinkedIn </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href="https://news.ycombinator.com/user?id=alilleybrinker"> Hacker News </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://lobste.rs/~alilleybrinker> Lobste.rs </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.reddit.com/user/alilleybrinker/> Reddit </a></ul><hr class=mb-4><p class=text-sm><a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/ai/>AI Policy</a> · <a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/name/>My Name</a></div></div></div>