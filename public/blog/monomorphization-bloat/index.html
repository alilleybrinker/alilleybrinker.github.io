<!doctype html><html lang=en-US><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Monomorphization Bloat — Andrew Lilley Brinker — Software Supply Chain Security</title><meta content="Monomorphization Bloat — Andrew Lilley Brinker — Software Supply Chain Security" name=title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" name=description><meta content=website property=og:type><meta content=https://www.alilleybrinker.com property=og:url><meta content="Monomorphization Bloat — Andrew Lilley Brinker — Software Supply Chain Security" property=og:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=og:description><meta content=https://www.alilleybrinker.com/social.png property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://www.alilleybrinker.com property=twitter:url><meta content="Monomorphization Bloat — Andrew Lilley Brinker — Software Supply Chain Security" property=twitter:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=twitter:description><meta content=https://www.alilleybrinker.com/social.png property=twitter:image><link href=https://www.alilleybrinker.com/main.css rel=stylesheet><body><div class="my-4 md:m-16 px-4 md:px-0 md:mx-auto subpixel-antialiased w-fit text-sm md:text-base"><div class="mb-6 md:mb-8"><nav><ul class="flex gap-4"><li><a class="hover:underline font-semibold" href=https://www.alilleybrinker.com/><span class=h-card><span class=p-given-name>Andrew</span> <span class=p-family-name>Lilley Brinker</span></span></a><li class=text-gray-400>/<li><a class=hover:underline href=https://www.alilleybrinker.com/blog/>Blog</a></ul></nav></div><h1 class="block mb-6 text-xl md:text-2xl font-bold">Monomorphization Bloat <span class="block md:inline text-sm md:text-base text-gray-500 font-normal md:ml-4">Posted on December 3, 2016</span> <span class="text-sm md:text-base text-gray-500 font-normal mr-2 md:mr-0 md:ml-4"> <a class="text-xs relative -top-[2px] py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.alilleybrinker.com/topics/rust/>Rust</a> </span></h1><div class="md:flex gap-16"><div class="prose prose-sm md:prose-base prose-p:text-black prose-li:text-black prose-a:text-black prose-a:font-normal prose-a:decoration-1 hover:prose-a:decoration-2 prose-a:underline-offset-2 hover:prose-a:underline-offset-auto prose-a:decoration-gray-400 hover:prose-a:decoration-gray-800 prose-code:after:content-[''] prose-code:before:content-[''] prose-blockquote:font-normal prose-blockquote:not-italic prose-blockquote:text-base prose-figure:bg-sky-50 prose-figure:p-4 prose-figure:rounded-md prose-blockquote:border-l-sky-200 prose-blockquote:text-sky-900 prose-figcaption:text-sky-900 prose-figcaption:opacity-70"><p>In this post I will discuss monomorphization: what it is, why it’s useful, and what problems can potentially arise from it, with a particular focus on the problem of monomorphization bloat. I will also look at options for dealing with monomorphization bloat in your codebase.</p><span id=continue-reading></span><div class="text-sm leading-5 bg-gray-100 rounded-md p-4 pb-1 mb-4"><span class="font-bold text-black block">This is a repost</span><p>The following is a reproduction of a blog post originally shared on my now-defunct blog Suspect Semantics. It was originally published on December 3rd, 2016.</div><p>Monomorphization is a compilation strategy to allow polymorphism with static dispatch. To explain how it works, we’ll look at the following function:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>do_the_thing</span><span>&LTT></span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>:</span><span> T</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// ... does the thing
</span><span style=color:#7c7f93>}
</span></code></pre><p>As you can see, this function takes in some type <code>T</code>. This means we can call the function with any type, like so:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>main</span><span style=color:#7c7f93>() {
</span><span>    </span><span style=color:#04a5e5>do_the_thing</span><span style=color:#7c7f93>(</span><span style=color:#fe640b>42</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span>    </span><span style=color:#04a5e5>do_the_thing</span><span style=color:#7c7f93>(</span><span style=color:#fe640b>8385.35</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span>    </span><span style=color:#04a5e5>do_the_thing</span><span style=color:#7c7f93>(</span><span style=color:#40a02b>"a string!"</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span style=color:#7c7f93>}
</span></code></pre><p>At compile time, the compiler sees that <code>do_the_thing</code> is called with three different types: <code>i32</code>, <code>f64</code>, and <code>&str</code>. So it creates three different functions based on <code>do_the_thing</code>, replacing the general <code>T</code> type with each of the three concrete types the function is actually called with. In the end, you get something like this:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>do_the_thing_1</span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>: </span><span style=color:#df8e1d;font-style:italic>i32</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// ... do the thing, with an i32!
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>do_the_thing_2</span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>: </span><span style=color:#df8e1d;font-style:italic>f64</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// ... do the thing, with an f64!
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>do_the_thing_3</span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>: </span><span style=color:#04a5e5;font-weight:700>&</span><span style=color:#df8e1d;font-style:italic>str</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// ... do the thing, with a &str!
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>main</span><span style=color:#7c7f93>() {
</span><span>    </span><span style=color:#04a5e5>do_the_thing_1</span><span style=color:#7c7f93>(</span><span style=color:#fe640b>42</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span>    </span><span style=color:#04a5e5>do_the_thing_2</span><span style=color:#7c7f93>(</span><span style=color:#fe640b>8385.35</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span>    </span><span style=color:#04a5e5>do_the_thing_3</span><span style=color:#7c7f93>(</span><span style=color:#40a02b>"a string!"</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span style=color:#7c7f93>}
</span></code></pre><p>This is monomorphization! The generated code is equivalent to you having written three different functions, but you didn’t have to actually write three functions! This is really cool, as writing the general version is a lot less work than writing a version for every concrete type you’ll use, and a lot more flexible too.<h2 id=bloat>Bloat</h2><p>The downside is that, by generating these functions, you potentially add bloat to the resulting binary. If you have a function with size <code>n</code>, and it’s called with <code>m</code> number of concrete types, it’ll have a size of <code>n×m</code> in the resulting binary! In some contexts, a large binary size can be a problem.<p>Thankfully, there are several options to deal with this. In my last post, I talked about a small conversion trick using <code>Into</code>. This is a fairly common trick in the Rust world, and can if you’re not careful cause the monomorphization bloat problem we’re discussing here. But imagine you have something like the following:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#d20f39>pub </span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>big_function</span><span>&LTT</span><span style=color:#179299>: </span><span style=color:#1e66f5;font-style:italic>Into</span><span><</span><span style=color:#df8e1d;font-style:italic>i32</span><span>>></span><span style=color:#04a5e5;font-weight:700>></span><span style=color:#7c7f93>(</span><span>x</span><span style=color:#179299>:</span><span> T</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// This is a giant function with hundreds of lines!
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// And it gets called with a lot of concrete types!
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// Oh no!
</span><span style=color:#7c7f93>}
</span></code></pre><p>The way monomorphization works, the entire body of the function gets copied. But in the case of conversion traits like <code>Into&LTT></code>, <code>From&LTT></code>, <code>AsRef&LTT></code>, <code>Borrow&LTT></code>, and <code>ToString</code>, you can actually separate the part that needs to be monomorphized from the rest of the function like so:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#d20f39>pub </span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>big_function</span><span>&LTT</span><span style=color:#179299>: </span><span style=color:#1e66f5;font-style:italic>Into</span><span><</span><span style=color:#df8e1d;font-style:italic>i32</span><span>>></span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>:</span><span> T</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#df8e1d;font-style:italic>let</span><span> x</span><span style=color:#179299>: </span><span style=color:#df8e1d;font-style:italic>i32 </span><span style=color:#04a5e5;font-weight:700>=</span><span> x</span><span style=color:#04a5e5;font-weight:700>.</span><span style=color:#04a5e5>into</span><span style=color:#7c7f93>()</span><span style=color:#179299>;
</span><span>    </span><span style=color:#04a5e5>_big_function</span><span style=color:#7c7f93>(</span><span>x</span><span style=color:#7c7f93>)
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>_big_function</span><span style=color:#7c7f93>(</span><span style=color:#dc8a78;font-style:italic>x</span><span style=color:#179299>: </span><span style=color:#df8e1d;font-style:italic>i32</span><span style=color:#7c7f93>) {
</span><span>    </span><span style=color:#9ca0b0;font-style:italic>// This is where all the rest of the original function body is now!
</span><span style=color:#7c7f93>}
</span></code></pre><p>By splitting out the conversion code from the function, you keep the part that the compiler will monomorphize, and thereby duplicate, quite small. This helps to keep the size of the resulting binary down.<p>Alternatively, you can remove the conversion trait abstraction, and instead require callers to do the conversion themselves before calling the function. This may make the API a little more tedious to use, but it avoids the potential problem of bloat by not requiring monomorphization at all.<p>Additionally, you can always try to shrink the sizes of your functions by refactoring. A big function is probably a sign of something gone wrong anyway.<h2 id=conclusion>Conclusion</h2><p>I don’t say any of this to encourage you not to use trait bounds or not to use some of the conversion trait niceties in your API. Generics and static dispatch are an important part of Rust, and it would be silly not to take advantage of these features. Just keep in mind the potential for bloat, and keep an eye on the size of your binary. If it grows too large and becomes a problem, hopefully you will be better equipped to understand what is happening, and to correct it.</div><div class="mt-8 md:mt-0 md:max-w-60"><figure class=mb-8><img class="rounded-full max-w-48" src=https://www.alilleybrinker.com/image/andrew.png></figure><p class="block text-xs mb-4 uppercase font-semibold">Elsewhere<ul class="mb-8 flex flex-wrap gap-x-1 gap-y-2"><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://github.com/alilleybrinker> GitHub </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://x.com/alilleybrinker> Twitter <span class=text-gray-500/75>/</span> X </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://bsky.app/profile/alilleybrinker.com> Bluesky </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://hachyderm.io/@alilleybrinker> Mastodon </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.linkedin.com/in/alilleybrinker> LinkedIn </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href="https://news.ycombinator.com/user?id=alilleybrinker"> Hacker News </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://lobste.rs/~alilleybrinker> Lobste.rs </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.reddit.com/user/alilleybrinker/> Reddit </a></ul><hr class=mb-4><p class=text-sm><a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/ai/>AI Policy</a> · <a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/name/>My Name</a></div></div></div>