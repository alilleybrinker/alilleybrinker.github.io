<!doctype html><html lang=en-US><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>String Types in Rust — Andrew Lilley Brinker — Software Supply Chain Security</title><meta content="String Types in Rust — Andrew Lilley Brinker — Software Supply Chain Security" name=title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" name=description><meta content=website property=og:type><meta content=https://www.alilleybrinker.com property=og:url><meta content="String Types in Rust — Andrew Lilley Brinker — Software Supply Chain Security" property=og:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=og:description><meta content=https://www.alilleybrinker.com/social.png property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://www.alilleybrinker.com property=twitter:url><meta content="String Types in Rust — Andrew Lilley Brinker — Software Supply Chain Security" property=twitter:title><meta content="I work on software supply chain security at MITRE, including serving as amember of the OmniBOR Working Group, where I lead development of the Rustimplementation, and as the project manager for Hipcheck, a tool forautomated supply chain risk assessment of software packages.
" property=twitter:description><meta content=https://www.alilleybrinker.com/social.png property=twitter:image><link href=https://www.alilleybrinker.com/main.css rel=stylesheet><body><div class="my-4 md:m-16 px-4 md:px-0 md:mx-auto subpixel-antialiased w-fit text-sm md:text-base"><div class="mb-6 md:mb-8"><nav><ul class="flex gap-4"><li><a class="hover:underline font-semibold" href=https://www.alilleybrinker.com/><span class=h-card><span class=p-given-name>Andrew</span> <span class=p-family-name>Lilley Brinker</span></span></a><li class=text-gray-400>/<li><a class=hover:underline href=https://www.alilleybrinker.com/blog/>Blog</a></ul></nav></div><h1 class="block mb-6 text-xl md:text-2xl font-bold">String Types in Rust <span class="block md:inline text-sm md:text-base text-gray-500 font-normal md:ml-4">Posted on March 27, 2016</span> <span class="text-sm md:text-base text-gray-500 font-normal mr-2 md:mr-0 md:ml-4"> <a class="text-xs relative -top-[2px] py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.alilleybrinker.com/topics/rust/>Rust</a> </span></h1><div class="md:flex gap-16"><div class="prose prose-sm md:prose-base prose-p:text-black prose-li:text-black prose-a:text-black prose-a:font-normal prose-a:decoration-1 hover:prose-a:decoration-2 prose-a:underline-offset-2 hover:prose-a:underline-offset-auto prose-a:decoration-gray-400 hover:prose-a:decoration-gray-800 prose-code:after:content-[''] prose-code:before:content-[''] prose-blockquote:font-normal prose-blockquote:not-italic prose-blockquote:text-base prose-figure:bg-sky-50 prose-figure:p-4 prose-figure:rounded-md prose-blockquote:border-l-sky-200 prose-blockquote:text-sky-900 prose-figcaption:text-sky-900 prose-figcaption:opacity-70"><p>This seems to be a common issue, so let’s talk about the different string types in the Rust programming language. In this post I’m going to explain the organization of Rust’s string types with <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> and <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> as examples, then get into the lesser-used string types—<a title="Rustdoc for the CString type" href=http://doc.rust-lang.org/std/ffi/struct.CString.html><code>CString</code></a>, <a title="Rustdoc for the CStr type" href=http://doc.rust-lang.org/std/ffi/struct.CStr.html><code>CStr</code></a>, <a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a>, <a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a>, <a title="Rustdoc for the PathBuf type" href=http://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a>, and <a title="Rustdoc for the Path type" href=http://doc.rust-lang.org/std/path/struct.Path.html><code>Path</code></a>—and how the <a title="Rustdoc for the Cow type" href=http://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow</code></a> container can make working with Rust strings easier.</p><span id=continue-reading></span><div class="text-sm leading-5 bg-gray-100 rounded-md p-4 pb-1 mb-4"><span class="font-bold text-black block">This was originally published on a different site.</span><p>This is a reproduction of a post of mine which was originally published on a now-defunct programming blog called “Suspect Semantics”. I am reproducing it here to give me something to refer to, as there have been times where I wanted to point people to this article. I don’t have any intent of bringing the original site back in full, but at least some of the content was good and is still reasonably correct and relevant to be worth preserving.</div><p>The most important thing to understand is that string types in Rust come in pairs, which I’ll call the “owned” variety and “slice” variety (<em>the term “variety” is being used here to mean roughly “set of types”, to make clear that “owned” and “slice” are not actual Rust types, but a notion of organization for Rust’s string types</em>). The “owned” variety of strings—<a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a>, <a title="Rustdoc for the CString type" href=http://doc.rust-lang.org/std/ffi/struct.CString.html><code>CString</code></a>, <a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a>, and <a title="Rustdoc for the PathBuf type" href=http://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a>—have ownership over their contents (hence the name!), and can grow or shrink. The “slice” variety of strings—<a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a>, <a title="Rustdoc for the CStr type" href=http://doc.rust-lang.org/std/ffi/struct.CStr.html><code>CStr</code></a>, <a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a>, and <a title="Rustdoc for the Path type" href=http://doc.rust-lang.org/std/path/struct.Path.html><code>Path</code></a>—are views into some collection of characters. There’s also the <a title="Rustdoc for the Cow type" href=http://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow</code></a> wrapper type, which can make working with the two varieties of strings easier while retaining good performance characteristics.<h2 id=owned-vs-slice-varieties-of-strings>“Owned” vs. “Slice” varieties of Strings</h2><p><a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> and <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> are, by far, the most common string types in Rust, so I will use them to illustrate the difference between the two varieties of string types. <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> (the “owned” variety of string type) is a wrapper for a heap-allocated buffer of UTF-8–encoded unicode codepoints. <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> (the “slice” variety of string type) is a buffer of UTF-8–encoded unicode codepoints that may be on the heap or in the program memory itself.<p>When you create a string literal in Rust, it is by default of type <code>&str</code>. There are two things this could mean, depending on how that buffer was created.<h3 id=slice-on-the-heap>“Slice” on the Heap</h3><p>If the reference is taken from a <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a>, it will be a reference to the contents of the <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a>’s internal buffer, which is on the heap. Handing out these references is a common pattern for effectively using “owned” variety strings in Rust. For convenience’s sake, all references to “owned” variety strings coerce to references to their “slice” variety equivalent. That is, <code>&String</code> becomes <code>&str</code>. It is considered good practice to use the latter type for function parameters taking a reference to a string.<h3 id=slice-in-program-memory>“Slice” in Program Memory</h3><p>If the buffer is a string literal, with or without an explicit lifetime, then the buffer will be located in program memory. In fact, all string literals have the <code>'static</code> lifetime by default, meaning they can be safely referenced from anywhere in the program. Note though that having a buffer with a <code>'static</code> lifetime is <em>not</em> the same as declaring a <code>static</code> variable. A buffer with a <code>'static</code> lifetime may be safely referenced from anywhere, but must still be passed to functions explicitly; it is not globally visible. A variable must be declared with the <code>static</code> keyword to be globally visible.<p>There is some nuance here though. When returning a <code>&str</code> from a function, the lifetime of the reference must be tied to either a single input lifetime, or a method taking either <code>&self</code> or <code>&mut self</code>. In the first case, the lifetime of the returned reference will be the lifetime of the single input reference. In the second case, the lifetime will be the lifetime of the reference to <code>self</code>.<p>If your function does not fit either of these cases, <code>rustc</code> will return an error, as in the following example:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>get_string</span><span style=color:#7c7f93>() </span><span style=color:#179299>-> </span><span style=color:#04a5e5;font-weight:700>&</span><span style=color:#df8e1d;font-style:italic>str </span><span style=color:#7c7f93>{
</span><span>    </span><span style=color:#40a02b>"A string!"
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>main</span><span style=color:#7c7f93>() {
</span><span>    </span><span style=color:#df8e1d;font-style:italic>let</span><span> string </span><span style=color:#04a5e5;font-weight:700>= </span><span style=color:#04a5e5>get_string</span><span style=color:#7c7f93>()</span><span style=color:#179299>;
</span><span>    println!</span><span style=color:#7c7f93>(</span><span style=color:#40a02b>"{}"</span><span style=color:#179299>,</span><span> string</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span style=color:#7c7f93>}
</span></code></pre><p>You can avoid the lifetime elision problems entirely by explicitly annotating the function in one of the following ways:<pre class=language-rust data-lang=rust style=color:#4c4f69;background-color:#eff1f5><code class=language-rust data-lang=rust><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>get_string_static</span><span style=color:#7c7f93>() </span><span style=color:#179299>-> </span><span style=color:#04a5e5;font-weight:700>&</span><span style=color:#d20f39>'static </span><span style=color:#df8e1d;font-style:italic>str </span><span style=color:#7c7f93>{
</span><span>    </span><span style=color:#40a02b>"A string!"
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>get_string_function_call</span><span><</span><span style=color:#d20f39>'a</span><span>></span><span style=color:#7c7f93>() </span><span style=color:#179299>-> </span><span style=color:#04a5e5;font-weight:700>&</span><span style=color:#d20f39>'a </span><span style=color:#df8e1d;font-style:italic>str </span><span style=color:#7c7f93>{
</span><span>    </span><span style=color:#40a02b>"A string!"
</span><span style=color:#7c7f93>}
</span><span>
</span><span style=color:#df8e1d;font-style:italic>fn </span><span style=color:#1e66f5;font-style:italic>main</span><span style=color:#7c7f93>() {
</span><span>    </span><span style=color:#df8e1d;font-style:italic>let</span><span> string_1 </span><span style=color:#04a5e5;font-weight:700>= </span><span style=color:#04a5e5>get_string_static</span><span style=color:#7c7f93>()</span><span style=color:#179299>;
</span><span>    </span><span style=color:#df8e1d;font-style:italic>let</span><span> string_2 </span><span style=color:#04a5e5;font-weight:700>= </span><span style=color:#04a5e5>get_string_function_call</span><span style=color:#7c7f93>()</span><span style=color:#179299>;
</span><span>
</span><span>    println!</span><span style=color:#7c7f93>(</span><span style=color:#40a02b>"{}"</span><span style=color:#179299>,</span><span> string_1</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span>    println!</span><span style=color:#7c7f93>(</span><span style=color:#40a02b>"{}"</span><span style=color:#179299>,</span><span> string_2</span><span style=color:#7c7f93>)</span><span style=color:#179299>;
</span><span style=color:#7c7f93>}
</span></code></pre><p>So what do you do if you want to return a string from a function without giving it a <code>'static</code> lifetime, or want to return a string whose contents aren’t known at compile time? You use the “owned” variety of string type, in this case: <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a>.<h3 id=why-owned-strings-exist>Why “Owned” Strings Exist</h3><p>The “owned” varities of strings are allocated on the heap, and do not suffer the same limitations of the “slice” varities. They may be freely moved around without safety issues, handing out slices of their internal buffer as needed. The “slice” varities do not have the same guarantees, and so can’t be used as freely.<p>If you want to avoid dealing with ownership and borrowing for strings, you can just turn every “slice” variety into an “owned” variety via the <a title="Rustdoc for the to_owned function" href=http://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned><code>to_owned()</code></a> method (provided by the <a title="Rustdoc for the ToOwned trait" href=http://doc.rust-lang.org/std/borrow/trait.ToOwned.html><code>ToOwned</code></a> trait, which all “owned” varities of string types implement), and only work with the “owned” varities, but doing so would incur performance penalties when you unecessarily allocate string buffers on the heap, and would be considered poor Rust style. Instead, it’s best to develop an understanding of when the two varities of strings are needed.<p>Another important thing to note is that because the “owned” varities of strings abstract away the underlying buffer, they can grow or shrink, possibly allocating a new underlying buffer and copying their contents to this new buffer. The “slice” varities of strings cannot be resized, as they may not even be on the heap.<p>The “slice” variety strings can only be accessed via what’s called a “fat pointer.” This is because slices are “dynamically-sized types,” meaning they do not carry information about their own length. They are simply some collection of contiguous memory. A “fat pointer” to a slice stores both a pointer to the memory in question and the length of the data stored at that memory location. This is all handled automatically by Rust, but it means that the “slice” variety of strings are interacted with via references, rather than being handled directly. For more detail about dynamically-sized types, check out “The Rustonomicon,” which <a title="Rustonomicon section on dynamically-sized types" href=https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts>covers them in detail</a>.<h2 id=the-string-type-pairs>The String Type Pairs</h2><p>The pairs of string types are differentiated from each other by the guarantees provided by the underlying buffer.<p><a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> and <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> : <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> and <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> are guaranteed to be valid UTF-8 encoded Unicode strings. If you’re wondering why UTF-8 is the standard encoding for Rust strings, check out the <a title="Rust FAQ answer about why UTF-8 is the standard encoding for Rust strings" href=https://www.rust-lang.org/faq.html#why-are-strings-utf-8>Rust FAQ’s answer to that question</a>. <a title="Rustdoc for the CString type" href=http://doc.rust-lang.org/std/ffi/struct.CString.html><code>CString</code></a> and <a title="Rustdoc for the CStr type" href=http://doc.rust-lang.org/std/ffi/struct.CStr.html><code>CStr</code></a> : <a title="Rustdoc for the CString type" href=http://doc.rust-lang.org/std/ffi/struct.CString.html><code>CString</code></a> and <a title="Rustdoc for the CStr type" href=http://doc.rust-lang.org/std/ffi/struct.CStr.html><code>CStr</code></a> are guaranteed to be compatible with C strings, and are usually used in FFI code. <a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a> and <a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a> : <a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a> and <a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a> are guaranteed to be platform-native strings (that is, they use the encoding of the current platform) that can be cheaply converted into <a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> and <a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a> types. They are usually used when interacting directly with the operating system. <a title="Rustdoc for the PathBuf type" href=http://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a> and <a title="Rustdoc for the Path type" href=http://doc.rust-lang.org/std/path/struct.Path.html><code>Path</code></a> : <a title="Rustdoc for the PathBuf type" href=http://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a> and <a title="Rustdoc for the Path type" href=http://doc.rust-lang.org/std/path/struct.Path.html><code>Path</code></a> are wrappers around <a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a> and <a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a> that provide convenient methods for operating on paths according to the rules of the current system. They are usually used when interacting with system paths.<h2 id=cow><a title="Rustdoc for the Cow type" href=http://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow</code></a></h2><p>There are times when working with strings in Rust that you want to cleanly abstract over the two varities of string types. Maybe you want a container that may hold either “owned” variety or “slice” variety strings, or you want to use slices except for cases where an “owned” variety is absolutely necessary. In these situations, use <a title="Rustdoc for the Cow type" href=http://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow</code></a>.<p><a title="Rustdoc for the Cow type" href=http://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow</code></a> (which stands for “Clone on Write”) is a container that can take in a “slice” variety of string type, and only convert that “slice” variety into an “owned” variety when absolutely necessary (when something attempts to write to the slice). This has the advantage of reducing the complexity of reasoning about ownership, while also helping keep unecessary allocations down. It is not a panacea, but it can be very helpful sometimes.<h2 id=conclusion>Conclusion</h2><p>That was a relatively quick explanation of string types in Rust. Hopefully that helped to clarify a bit of why the different string types exist, and why they are useful. As a final reference, here is a table of the different types:<table><thead><tr><th style=text-align:left>Guarantees<th style=text-align:left>“Slice” variety<th style=text-align:left>“Owned” variety<tbody><tr><td style=text-align:left>UTF-8<td style=text-align:left><a title="Rustdoc for the str type" href=http://doc.rust-lang.org/std/primitive.str.html><code>str</code></a><td style=text-align:left><a title="Rustdoc for the String type" href=http://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a><tr><td style=text-align:left>C-compatible<td style=text-align:left><a title="Rustdoc for the CStr type" href=http://doc.rust-lang.org/std/ffi/struct.CStr.html><code>CStr</code></a><td style=text-align:left><a title="Rustdoc for the CString type" href=http://doc.rust-lang.org/std/ffi/struct.CString.html><code>CString</code></a><tr><td style=text-align:left>OS-compatible<td style=text-align:left><a title="Rustdoc for the OsStr type" href=http://doc.rust-lang.org/std/ffi/struct.OsStr.html><code>OsStr</code></a><td style=text-align:left><a title="Rustdoc for the OsString type" href=http://doc.rust-lang.org/std/ffi/struct.OsString.html><code>OsString</code></a><tr><td style=text-align:left>System path<td style=text-align:left><a title="Rustdoc for the Path type" href=http://doc.rust-lang.org/std/path/struct.Path.html><code>Path</code></a><td style=text-align:left><a title="Rustdoc for the PathBuf type" href=http://doc.rust-lang.org/std/path/struct.PathBuf.html><code>PathBuf</code></a></table><hr><p>Updated (3/28/2016):<ul><li>This post has been updated based on corrections from <a title="Feedback from CryZe92 on the Rust subreddit" href=https://www.reddit.com/r/rust/comments/4c7wq2/string_types_in_rust/d1fsxd4>CryZe92</a> and <a title="Feedback from Ilogiq on the Rust subreddit" href=https://www.reddit.com/r/rust/comments/4c7wq2/string_types_in_rust/d1fyvjo>Ilogiq</a> on the Rust subreddit. Thanks to both of them for the help!</ul><p>Updated (3/29/2016):<ul><li>Replaced the word “sort” with “variety” based on feedback from <a href="https://news.ycombinator.com/item?id=11380530" title="Feedback from rkangel on Hacker News">rkangel</a> on Hacker News.<li>Clarified the wording of the unicode explanation, based on feedback from <a href="https://news.ycombinator.com/item?id=11379308" title="Feedback from nothrabannosir on Hacker News">nothrabannosir</a>, also on Hacker News.<li>Fixed a typo based on feedback from <a title="Feedback from respeccing on Twitter" href=https://twitter.com/respeccing/status/714551241615998976>respeccing</a> on Twitter.<li>Reworded the transition into the explanation of “owned” string types, based on feedback from <a title="Feedback from bjzaba on the Rust subreddit" href=https://www.reddit.com/r/rust/comments/4c7wq2/string_types_in_rust/d1hbnmp>bjzaba</a> from the Rust subreddit.</ul><p>Updated (3/31/2016):<ul><li>Replaced “three” with “two,” fixing an ommission from earlier changes.</ul></div><div class="mt-8 md:mt-0 md:max-w-60"><figure class=mb-8><img class="rounded-full max-w-48" src=https://www.alilleybrinker.com/image/andrew.png></figure><p class="block text-xs mb-4 uppercase font-semibold">Elsewhere<ul class="mb-8 flex flex-wrap gap-x-1 gap-y-2"><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://github.com/alilleybrinker> GitHub </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://x.com/alilleybrinker> Twitter <span class=text-gray-500/75>/</span> X </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://bsky.app/profile/alilleybrinker.com> Bluesky </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://hachyderm.io/@alilleybrinker> Mastodon </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.linkedin.com/in/alilleybrinker> LinkedIn </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href="https://news.ycombinator.com/user?id=alilleybrinker"> Hacker News </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://lobste.rs/~alilleybrinker> Lobste.rs </a><li><a class="text-sm py-1 px-2 rounded-md bg-gray-100 hover:bg-gray-600 hover:text-gray-100" href=https://www.reddit.com/user/alilleybrinker/> Reddit </a></ul><hr class=mb-4><p class=text-sm><a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/ai/>AI Policy</a> · <a class="text-gray-500 hover:text-gray-800" href=https://www.alilleybrinker.com/name/>My Name</a></div></div></div>